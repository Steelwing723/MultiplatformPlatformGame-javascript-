<!--
Name: Joshua Davis
UAID: 010946462
Date: 11/12/2020
Assignment 7	[mario.html]
Description: An implementation of assignment 5 in Javascript
-------------------------------------------------------------------------------------------------

Tips:
Classes should begin with a capital letter, while
methods should begin with a lowercase letter

You can use functions in place of classes,
but you don't have to for this project.

addEventListener and setInterval both use
closures in their calls. These calls expect
simple functions, so we wrapped our class methods
in a wrapper function that they can use. These wrapper
functions have access to the local variables because they
retain a reference to the current stack frame, which
keeps it alive even after the outer function returns.

-->

<head> 
	<title>The Friendly Goomba</title>
	<meta charset="UTF-8"> <!-- character set, allows for specific characters -->
</head>
<body>
<br> <!--breaking return-->
<canvas id="myCanvas" width="1000" height="500" style="border:1px solid #cccccc;"></canvas>

<script type="text/javascript">


class Sprite 
{
	constructor(x, y, image_url, update_method, onclick_method)
	{
		this.x = x;
		this.y = y;
		this.image = new Image();
		this.image.src = image_url;
		this.update = update_method;
		this.onclick = onclick_method;
	}

	set_destination(x, y)
	{
		this.dest_x = x;
		this.dest_y = y;
	}

	ignore_click(x, y)
	{
	}

	move(dx, dy)
	{
		this.dest_x = this.x + dx;
		this.dest_y = this.y + dy;
	}

	go_toward_destination()
	{
		if(this.dest_x === undefined)
			return;

		if(this.x < this.dest_x)
			this.x++;
		else if(this.x > this.dest_x)
			this.x--;
		if(this.y < this.dest_y)
			this.y++;
		else if(this.y > this.dest_y)
			this.y--;
	}

	sit_still()
	{
	}
}






class Model
{
	constructor()
	{
		this.sprites = [];
		this.sprites.push(new Sprite(200, 100, "lettuce.png", Sprite.prototype.sit_still, Sprite.prototype.ignore_click));
		this.turtle = new Sprite(50, 50, "turtle.png", Sprite.prototype.go_toward_destination, Sprite.prototype.set_destination);
		this.sprites.push(this.turtle);
		this.mario = new Sprite(60, 95, "images/marioR1.png", Sprite.prototype.go_toward_destination, Sprite.prototype.set_destination);
		this.sprites.push(this.mario);
	}

	update()
	{
		for(let i = 0; i < this.sprites.length; i++)
		{
			this.sprites[i].update();
		}
	}

	onclick(x, y)
	{
		for(let i = 0; i < this.sprites.length; i++)
		{
			this.sprites[i].onclick(x, y);
		}
	}

	move(dx, dy)
	{
		this.turtle.move(dx, dy);
	}
}




class View
{
	constructor(model)
	{
		this.model = model;
		<!-- getElementById() returns an object that represents an element in the HTML DOM. -->
		<!-- This goes after the <canvas> tag so that it will succeed in finding "myCanvas" -->
		this.canvas = document.getElementById("myCanvas"); 
		this.turtle = new Image();
		this.turtle.src = "turtle.png"; <!-- Causes browser to request the turtle.png image. May take time. -->
	}

	update()
	{
		let ctx = this.canvas.getContext("2d");
		ctx.clearRect(0, 0, 1000, 500);
		for(let i = 0; i < this.model.sprites.length; i++)
		{
			let sprite = this.model.sprites[i];
			ctx.drawImage(sprite.image, sprite.x, sprite.y);
		}
	}
}







class Controller
{
	constructor(model, view)
	{
		this.model = model; <!-- must use "this", as it refers to the variable associated with this class-->
		this.view = view;
		this.key_right = false;
		this.key_left = false;
		this.key_up = false;
		this.key_down = false;
		let self = this; <!-- sets self to this, because when we add event listeners, we have a function that-->
						 <!-- needs to be passed "this", and it can sometimes mess it up if "this" is used.	 -->
		view.canvas.addEventListener("click", function(event) { self.onClick(event); });
		document.addEventListener('keydown', function(event) { self.keyDown(event); }, false);
		document.addEventListener('keyup', function(event) { self.keyUp(event); }, false);
	}

	onClick(event)
	{
		this.model.onclick(event.pageX - this.view.canvas.offsetLeft, event.pageY - this.view.canvas.offsetTop);
	}

	keyDown(event)
	{
		if(event.keyCode == 39) this.key_right = true;
		else if(event.keyCode == 37) this.key_left = true;
		else if(event.keyCode == 38) this.key_up = true;
		else if(event.keyCode == 40) this.key_down = true;
		<!-- WASD support --!>
		else if(event.keyCode == 68) this.key_right = true;
		else if(event.keyCode == 65) this.key_left = true;
		else if(event.keyCode == 87) this.key_up = true;
		else if(event.keyCode == 83) this.key_down = true;
	}

	keyUp(event)
	{
		if(event.keyCode == 39) this.key_right = false;
		else if(event.keyCode == 37) this.key_left = false;
		else if(event.keyCode == 38) this.key_up = false;
		else if(event.keyCode == 40) this.key_down = false;
		<!-- WASD support --!>
		else if(event.keyCode == 68) this.key_right = false;
		else if(event.keyCode == 65) this.key_left = false;
		else if(event.keyCode == 87) this.key_up = false;
		else if(event.keyCode == 83) this.key_down = false;
	}

	update()
	{
		let dx = 0;
		let dy = 0;
		if(this.key_right) dx++;
		if(this.key_left) dx--;
		if(this.key_up) dy--;
		if(this.key_down) dy++;
		if(dx != 0 || dy != 0)
			this.model.move(dx, dy);
	}
}

<!-- class Mario extends Sprite -->
<!-- { -->
	<!-- constructor(x, y) -->
	<!-- { -->
		<!-- this.x = x; -->
		<!-- this.y = y; -->
		<!-- this.w = 60; -->
		<!-- this.h = 95; -->
	<!-- } -->
<!-- } -->



class Game
{
	constructor() <!-- Initializes everything -->
	{
		this.model = new Model();
		this.view = new View(this.model);
		this.controller = new Controller(this.model, this.view);
	}

	onTimer()
	{
		this.controller.update();
		this.model.update();
		this.view.update();
	}
}

<!-- Below is essentially the "main()" function-->
let game = new Game(); 
let timer = setInterval(function() { game.onTimer(); }, 40);

</script>

</body>
